<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>角色對弈遊戲</title>
    <style>
            font-family: 'Arial', 'Microsoft JhengHei', sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: #4a4a9c;
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        
        .game-area {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .control-panel {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .game-board {
            flex: 2;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .character-selection {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .character-card {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .character-card.selected {
            background-color: #e6f7ff;
            border-color: #1890ff;
        }
        
        .character-card.banned {
            background-color: #ffebee;
            border-color: #f44336;
            opacity: 0.7;
        }
        
        .board-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 60px);
            gap: 2px;
            background-color: #ccc;
            padding: 2px;
            border-radius: 5px;
        }
        
        .board-cell {
            background-color: #fff;
            border-radius: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }
        
        .board-cell:hover {
            background-color: #f0f0f0;
        }
        
        .board-cell.highlight {
            background-color: #fffde7;
        }
        
        .player-a {
            background-color: #e3f2fd;
        }
        
        .player-b {
            background-color: #fce4ec;
        }
        
        .character-on-board {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.8em;
        }
        
        .character-on-board .name {
            font-weight: bold;
        }
        
        .character-on-board .hp {
            font-size: 0.8em;
            color: #666;
        }
        
        .battle-log {
            margin-top: 20px;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .phase-indicator {
            margin-top: 20px;
            padding: 10px;
            background-color: #4a4a9c;
            color: white;
            text-align: center;
            border-radius: 5px;
        }
        
        .action-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4a4a9c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #3a3a8c;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .hp-bar {
            width: 100%;
            height: 4px;
            background-color: #ddd;
            border-radius: 2px;
            margin-top: 2px;
        }
        
        .hp-bar-fill {
            height: 100%;
            background-color: #4caf50;
            border-radius: 2px;
        }
        
        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        
        .player-panel {
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            width: 48%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .player-panel h3 {
            margin-top: 0;
            color: #4a4a9c;
        }
        
        .player-panel.player-a h3 {
            color: #1565c0;
        }
        
        .player-panel.player-b h3 {
            color: #c2185b;
        }
        
        .player-characters {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .mini-character {
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 5px;
            width: 80px;
            text-align: center;
            font-size: 0.8em;
        }
        
        .mini-character.selected {
            background-color: #e6f7ff;
            border-color: #1890ff;
        }
        .character-card {
            position: relative;
        }
        .character-card .status {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.8em;
            color: #666;
        }
        .battle-log p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>角色對弈遊戲</h1>
            <p>選擇角色、佈置陣型，展開戰略對決！</p>
        </header>
        
        <div class="phase-indicator" id="phaseIndicator">
            遊戲階段：禁用階段 (Ban Phase)
        </div>
        
        <div class="player-info">
            <div class="player-panel player-a">
                <h3>玩家 A</h3>
                <div id="playerA-banned">禁用角色：尚未選擇</div>
                <div id="playerA-characters" class="player-characters"></div>
            </div>
            <div class="player-panel player-b">
                <h3>玩家 B</h3>
                <div id="playerB-banned">禁用角色：尚未選擇</div>
                <div id="playerB-characters" class="player-characters"></div>
            </div>
        </div>
        
        <div class="game-area">
            <div class="control-panel">
                <h2>角色選擇</h2>
                <div class="character-selection" id="characterSelection"></div>
                <div class="action-buttons">
                    <button id="banBtn">禁用選中角色</button>
                    <button id="pickBtn">選擇角色</button>
                    <button id="placeBtn">佈置角色</button>
                    <button id="battleBtn">執行戰鬥</button>
                    <button id="resetBtn">重置遊戲</button>
                </div>
            </div>
            <div class="game-board">
                <h2>遊戲棋盤</h2>
                <div class="board-grid" id="gameBoard"></div>
                <div class="battle-log" id="battleLog">
                    <p>遊戲開始，請進行禁用階段...</p>
                </div>
            </div>
        </div>
    </div>

   <script>
    // 角色對弈遊戲原型
    class Game {
        constructor() {
            this.characters = [];
            this.initializeCharacters();
            this.playerA = {
                name: "玩家A",
                selectedCharacters: [],
                bannedCharacter: null,
                placedCharacters: new Array(8).fill().map(() => new Array(8).fill(null))
            };
            this.playerB = {
                name: "玩家B",
                selectedCharacters: [],
                bannedCharacter: null,
                placedCharacters: new Array(8).fill().map(() => new Array(8).fill(null))
            };
            this.currentPhase = "ban";
            this.currentTurn = "playerA";
            this.gameBoard = new Array(8).fill().map(() => new Array(8).fill(null));
            this.battleTurn = 0;
            this.selectedCharacter = null;
        }

        initializeCharacters() {
            this.characters = [
                {
                    id: 1,
                    name: "Selina",
                    title: "無差鱉攻擊",
                    hp: 800,
                    attack: 120,
                    position: "mid",
                    skill: (self, allCharacters) => {
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            console.log(`${self.name} 使用無差鱉攻擊，隨機攻擊 ${target.name}！`);
                            target.hp -= self.attack;
                            return `${self.name} 變成一隻鱉，對 ${target.name} 造成 ${self.attack} 點傷害！`;
                        }
                        return `${self.name} 使用無差鱉攻擊，但沒有目標！`;
                    }
                },
                {
                    id: 2,
                    name: "Vincent",
                    title: "種族之力",
                    hp: 900,
                    attack: 150,
                    position: "front",
                    skill: (self, allCharacters) => {
                        const frontEnemies = allCharacters.filter(c => 
                            c.owner !== self.owner && 
                            c.hp > 0 && 
                            c.position === "front"
                        );
                        let damage = 0;
                        if (frontEnemies.length > 0) {
                            frontEnemies.forEach(enemy => {
                                enemy.hp -= self.attack;
                                damage += self.attack;
                            });
                            return `${self.name} 使用種族之力，對前排敵人造成總共 ${damage} 點傷害！`;
                        }
                        return `${self.name} 使用種族之力，但沒有前排敵人！`;
                    }
                },
                {
                    id: 3,
                    name: "Lorenzo",
                    title: "暗器牙籤",
                    hp: 700,
                    attack: 100,
                    position: "back",
                    skill: (self, allCharacters) => {
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        let damage = 0;
                        if (enemies.length > 0) {
                            const targets = [];
                            for (let i = 0; i < Math.min(3, enemies.length); i++) {
                                const randomIndex = Math.floor(Math.random() * enemies.length);
                                const target = enemies[randomIndex];
                                target.hp -= Math.floor(self.attack * 0.7);
                                damage += Math.floor(self.attack * 0.7);
                                targets.push(target.name);
                                enemies.splice(randomIndex, 1);
                            }
                            return `${self.name} 使用暗器牙籤，對 ${targets.join(", ")} 造成總共 ${damage} 點傷害！`;
                        }
                        return `${self.name} 使用暗器牙籤，但沒有目標！`;
                    }
                },
                {
                    id: 4,
                    name: "Bonnie",
                    title: "兔子跳",
                    hp: 650,
                    attack: 80,
                    position: "mid",
                    skill: (self, allCharacters) => {
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            target.charmed = true;
                            target.originalOwner = target.owner;
                            target.owner = self.owner;
                            return `${self.name} 使用兔子跳，魅惑了 ${target.name}，使其暫時為我方作戰！`;
                        }
                        return `${self.name} 使用兔子跳，但沒有目標！`;
                    }
                },
                {
                    id: 5,
                    name: "Amelia",
                    title: "電鑽攻擊",
                    hp: 750,
                    attack: 180,
                    position: "front",
                    skill: (self, allCharacters) => {
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[0]; // 攻擊最近的敵人
                            const damage = self.attack * 1.5;
                            target.hp -= damage;
                            return `${self.name} 使用電鑽攻擊，對 ${target.name} 造成 ${damage} 點多段傷害！`;
                        }
                        return `${self.name} 使用電鑽攻擊，但沒有目標！`;
                    }
                },
                {
                    id: 6,
                    name: "Ethan",
                    title: "周一路就是俗辣",
                    hp: 850,
                    attack: 90,
                    position: "mid",
                    skill: (self, allCharacters) => {
                        if (self.hp < self.maxHp * 0.3) {
                            self.position = "back";
                            const healing = Math.floor(self.maxHp * 0.2);
                            self.hp += healing;
                            return `${self.name} 使用周一路就是俗辣，退到後排並恢復 ${healing} 點生命值！`;
                        }
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            target.hp -= self.attack;
                            return `${self.name} 攻擊 ${target.name} 造成 ${self.attack} 點傷害！`;
                        }
                        return `${self.name} 攻擊，但沒有目標！`;
                    }
                },
                {
                    id: 7,
                    name: "Ean",
                    title: "暗影肥豬",
                    hp: 1200,
                    attack: 70,
                    position: "front",
                    skill: (self, allCharacters) => {
                        if (self.hp < self.maxHp * 0.5 && !self.damageReduction) {
                            self.damageReduction = true;
                            return `${self.name} 使用暗影肥豬，獲得50%傷害減免！`;
                        }
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[0]; // 攻擊最近的敵人
                            target.hp -= self.attack;
                            return `${self.name} 攻擊 ${target.name} 造成 ${self.attack} 點傷害！`;
                        }
                        return `${self.name} 攻擊，但沒有目標！`;
                    }
                },
                {
                    id: 8,
                    name: "Andrew",
                    title: "數學很好玩",
                    hp: 700,
                    attack: 110,
                    position: "mid",
                    skill: (self, allCharacters) => {
                        if (!self.skillCooldown || self.skillCooldown <= 0) {
                            const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                            if (enemies.length > 0) {
                                const target = enemies[Math.floor(Math.random() * enemies.length)];
                                target.stunned = 2; // 暈眩2回合
                                self.skillCooldown = 3; // 技能冷卻3回合
                                return `${self.name} 使用數學很好玩，變身瘋狂Josh，使 ${target.name} 暈眩2回合！`;
                            }
                            return `${self.name} 使用數學很好玩，但沒有目標！`;
                        } else {
                            self.skillCooldown--;
                            const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                            if (enemies.length > 0) {
                                const target = enemies[Math.floor(Math.random() * enemies.length)];
                                target.hp -= self.attack;
                                return `${self.name} 技能冷卻中，攻擊 ${target.name} 造成 ${self.attack} 點傷害！`;
                            }
                            return `${self.name} 技能冷卻中，攻擊，但沒有目標！`;
                        }
                    }
                },
                {
                    id: 9,
                    name: "Ian",
                    title: "死亡小丑",
                    hp: 850,
                    attack: 100,
                    position: "front",
                    skill: (self, allCharacters) => {
                        if (self.hp < self.maxHp * 0.2 && !self.physicalImmunity) {
                            self.physicalImmunity = 2; // 物理免疫2回合
                            return `${self.name} 使用死亡小丑，獲得2回合物理免疫！`;
                        }
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            target.hp -= self.attack;
                            return `${self.name} 攻擊 ${target.name} 造成 ${self.attack} 點傷害！`;
                        }
                        return `${self.name} 攻擊，但沒有目標！`;
                    }
                },
                {
                    id: 10,
                    name: "Antony",
                    title: "糖糖攻擊",
                    hp: 780,
                    attack: 95,
                    position: "mid",
                    skill: (self, allCharacters) => {
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            if (!target.sugarMarks) {
                                target.sugarMarks = 0;
                            }
                            target.sugarMarks++;
                            target.hp -= self.attack;
                            let message = `${self.name} 使用糖糖攻擊，對 ${target.name} 造成 ${self.attack} 點傷害，並附加了1層印記！`;
                            if (target.sugarMarks >= 5) {
                                const explosionDamage = self.attack * 2;
                                target.hp -= explosionDamage;
                                target.sugarMarks = 0;
                                message += `\n${target.name} 的5層印記爆炸，造成額外 ${explosionDamage} 點傷害！`;
                            }
                            return message;
                        }
                        return `${self.name} 使用糖糖攻擊，但沒有目標！`;
                    }
                },
                {
                    id: 11,
                    name: "Kelvin",
                    title: "巨型糖寶寶",
                    hp: 1000,
                    attack: 60,
                    position: "front",
                    skill: (self, allCharacters) => {
                        if (!self.transformed) {
                            self.transformed = true;
                            self.hp = self.hp * 5;
                            self.maxHp = self.maxHp * 5;
                            return `${self.name} 使用巨型糖寶寶，血量提升至 ${self.hp}！`;
                        }
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            target.hp -= self.attack;
                            return `${self.name} 攻擊 ${target.name} 造成 ${self.attack} 點傷害！`;
                        }
                        return `${self.name} 攻擊，但沒有目標！`;
                    }
                },
                {
                    id: 12,
                    name: "Emily",
                    title: "我們都是臭婊",
                    hp: 730,
                    attack: 105,
                    position: "back",
                    skill: (self, allCharacters) => {
                        const enemies = allCharacters.filter(c => c.owner !== self.owner && c.hp > 0);
                        if (enemies.length > 0) {
                            const target = enemies[Math.floor(Math.random() * enemies.length)];
                            target.charmed = true;
                            target.attackReduction = 0.5;
                            target.originalOwner = target.owner;
                            target.owner = self.owner;
                            return `${self.name} 使用我們都是臭婊，使 ${target.name} 轉為己方，並降低其50%攻擊力！`;
                        }
                        return `${self.name} 使用我們都是臭婊，但沒有目標！`;
                    }
                }
            ];
        }

        banCharacter(player, characterId) {
            if (this.currentPhase !== "ban") throw new Error("現在不是禁用階段!");
            if (this.currentTurn !== player) throw new Error("現在不是您的回合!");
            
            const character = this.characters.find(c => c.id === characterId);
            if (!character) throw new Error("角色不存在!");
            
            if (player === "playerA") {
                this.playerA.bannedCharacter = character;
                this.currentTurn = "playerB";
            } else {
                this.playerB.bannedCharacter = character;
                this.currentPhase = "pick";
                this.currentTurn = "playerA";
            }
            
            return `${player === "playerA" ? this.playerA.name : this.playerB.name} 禁用了角色 ${character.name}!`;
        }

        pickCharacter(player, characterId) {
            if (this.currentPhase !== "pick") throw new Error("現在不是選擇階段!");
            if (this.currentTurn !== player) throw new Error("現在不是您的回合!");
            
            const character = this.characters.find(c => c.id === characterId);
            if (!character) throw new Error("角色不存在!");
            
            if (
                (this.playerA.bannedCharacter && this.playerA.bannedCharacter.id === characterId) ||
                (this.playerB.bannedCharacter && this.playerB.bannedCharacter.id === characterId) ||
                this.playerA.selectedCharacters.some(c => c.id === characterId) ||
                this.playerB.selectedCharacters.some(c => c.id === characterId)
            ) throw new Error("該角色已被禁用或選擇!");
            
            if (player === "playerA") {
                this.playerA.selectedCharacters.push({...character, owner: "playerA", maxHp: character.hp});
                if (this.playerA.selectedCharacters.length < 2) {
                    this.currentTurn = "playerB";
                } else if (this.playerA.selectedCharacters.length === 2) {
                    if (this.playerB.selectedCharacters.length < 2) this.currentTurn = "playerB";
                    else this.currentTurn = "playerA";
                } else if (this.playerA.selectedCharacters.length === 3) {
                    this.currentTurn = "playerB";
                } else if (this.playerA.selectedCharacters.length === 4) {
                    if (this.playerB.selectedCharacters.length < 4) this.currentTurn = "playerB";
                    else {
                        this.currentPhase = "placement";
                        this.currentTurn = "both";
                    }
                }
            } else {
                this.playerB.selectedCharacters.push({...character, owner: "playerB", maxHp: character.hp});
                if (this.playerB.selectedCharacters.length < 2) {
                    this.currentTurn = "playerA";
                } else if (this.playerB.selectedCharacters.length === 2) {
                    if (this.playerA.selectedCharacters.length < 2) this.currentTurn = "playerA";
                    else this.currentTurn = "playerB";
                } else if (this.playerB.selectedCharacters.length === 3) {
                    this.currentTurn = "playerA";
                } else if (this.playerB.selectedCharacters.length === 4) {
                    if (this.playerA.selectedCharacters.length < 4) this.currentTurn = "playerA";
                    else {
                        this.currentPhase = "placement";
                        this.currentTurn = "both";
                    }
                }
            }
            
            return `${player === "playerA" ? this.playerA.name : this.playerB.name} 選擇了角色 ${character.name}!`;
        }

        placeCharacter(player, characterIndex, row, col) {
            if (this.currentPhase !== "placement") throw new Error("現在不是佈置階段!");
            
            const playerObj = player === "playerA" ? this.playerA : this.playerB;
            if (characterIndex < 0 || characterIndex >= playerObj.selectedCharacters.length) throw new Error("角色索引無效!");
            
            if (row < 0 || row >= 8 || col < 0 || col >= 8) throw new Error("位置無效!");
            
            if (playerObj.placedCharacters[row][col] !== null) throw new Error("該位置已被佔用!");
            
            const character = playerObj.selectedCharacters[characterIndex];
            playerObj.placedCharacters[row][col] = character;
            
            let allPlaced = true;
            let placedCountA = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (this.playerA.placedCharacters[r][c] !== null) placedCountA++;
                }
            }
            
            let placedCountB = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (this.playerB.placedCharacters[r][c] !== null) placedCountB++;
                }
            }
            
            if (placedCountA < this.playerA.selectedCharacters.length || 
                placedCountB < this.playerB.selectedCharacters.length) {
                allPlaced = false;
            }
            
            if (allPlaced) {
                this.initializeBattle();
                this.currentPhase = "battle";
            }
            
            return `${player === "playerA" ? this.playerA.name : this.playerB.name} 將 ${character.name} 佈置在位置 (${row}, ${col})!`;
        }

        initializeBattle() {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (this.playerA.placedCharacters[r][c] !== null) {
                        const character = this.playerA.placedCharacters[r][c];
                        character.gridRow = r;
                        character.gridCol = c;
                        if (r < 3) character.position = "front";
                        else if (r < 6) character.position = "mid";
                        else character.position = "back";
                        this.gameBoard[r][c] = character;
                    }
                    if (this.playerB.placedCharacters[r][c] !== null) {
                        const character = this.playerB.placedCharacters[r][c];
                        character.gridRow = r;
                        character.gridCol = c;
                        if (r < 3) character.position = "front";
                        else if (r < 6) character.position = "mid";
                        else character.position = "back";
                        this.gameBoard[r][c] = character;
                    }
                }
            }
            this.battleTurn = 0;
        }

        executeBattleTurn() {
            if (this.currentPhase !== "battle") throw new Error("現在不是戰鬥階段!");
            
            this.battleTurn++;
            console.log(`===== 回合 ${this.battleTurn} =====`);
            
            const allCharacters = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (this.gameBoard[r][c] !== null && this.gameBoard[r][c].hp > 0) {
                        allCharacters.push(this.gameBoard[r][c]);
                    }
                }
            }
            
            const battleLog = [];
            
            for (const character of allCharacters) {
                if (character.stunned > 0) {
                    character.stunned--;
                    battleLog.push(`${character.name} 暈眩中，剩餘 ${character.stunned} 回合`);
                    continue;
                }
                
                if (character.physicalImmunity > 0) {
                    character.physicalImmunity--;
                    if (character.physicalImmunity === 0) {
                        battleLog.push(`${character.name} 的物理免疫效果消失`);
                    } else {
                        battleLog.push(`${character.name} 的物理免疫效果剩餘 ${character.physicalImmunity} 回合`);
                    }
                }
                
                if (character.charmed) {
                    character.charmed = false;
                    character.owner = character.originalOwner;
                    battleLog.push(`${character.name} 魅惑效果消失，回到 ${character.owner} 方`);
                }
            }
            
            for (const character of allCharacters) {
                if (character.stunned > 0) continue;
                const skillResult = character.skill(character, allCharacters);
                battleLog.push(skillResult);
            }
            
            const playerACharacters = allCharacters.filter(c => c.owner === "playerA" && c.hp > 0);
            const playerBCharacters = allCharacters.filter(c => c.owner === "playerB" && c.hp > 0);
            
            if (playerACharacters.length === 0 || playerBCharacters.length === 0) {
                this.currentPhase = "end";
                if (playerACharacters.length === 0 && playerBCharacters.length === 0) {
                    battleLog.push("戰鬥結束，雙方平局!");
                } else if (playerACharacters.length === 0) {
                    battleLog.push(`戰鬥結束，${this.playerB.name} 獲勝!`);
                } else {
                    battleLog.push(`戰鬥結束，${this.playerA.name} 獲勝!`);
                }
            } else if (this.battleTurn >= 20) {
                this.currentPhase = "end";
                if (playerACharacters.length > playerBCharacters.length) {
                    battleLog.push(`回合數達到上限，${this.playerA.name} 獲勝!`);
                } else if (playerBCharacters.length > playerACharacters.length) {
                    battleLog.push(`回合數達到上限，${this.playerB.name} 獲勝!`);
                } else {
                    battleLog.push("回合數達到上限，雙方平局!");
                }
            }
            
            return battleLog;
        }

        getGameState() {
            return {
                phase: this.currentPhase,
                turn: this.currentTurn,
                playerA: {
                    name: this.playerA.name,
                    bannedCharacter: this.playerA.bannedCharacter ? this.playerA.bannedCharacter.name : null,
                    selectedCharacters: this.playerA.selectedCharacters.map(c => ({ 
                        name: c.name, 
                        hp: c.hp, 
                        maxHp: c.maxHp 
                    }))
                },
                playerB: {
                    name: this.playerB.name,
                    bannedCharacter: this.playerB.bannedCharacter ? this.playerB.bannedCharacter.name : null,
                    selectedCharacters: this.playerB.selectedCharacters.map(c => ({ 
                        name: c.name, 
                        hp: c.hp,
                        maxHp: c.maxHp
                    }))
                },
                battleTurn: this.battleTurn,
                gameBoard: this.gameBoard.map(row => 
                    row.map(cell => cell ? { 
                        name: cell.name, 
                        owner: cell.owner, 
                        hp: cell.hp,
                        maxHp: cell.maxHp
                    } : null)
                )
            };
        }

        resetGame() {
            this.playerA.selectedCharacters = [];
            this.playerA.bannedCharacter = null;
            this.playerA.placedCharacters = new Array(8).fill().map(() => new Array(8).fill(null));
            this.playerB.selectedCharacters = [];
            this.playerB.bannedCharacter = null;
            this.playerB.placedCharacters = new Array(8).fill().map(() => new Array(8).fill(null));
            this.currentPhase = "ban";
            this.currentTurn = "playerA";
            this.gameBoard = new Array(8).fill().map(() => new Array(8).fill(null));
            this.battleTurn = 0;
            this.selectedCharacter = null;
            return "遊戲已重置!";
        }
    }

    // 遊戲前端界面
    class GameFrontend {
        constructor() {
            this.game = new Game();
            this.initializeUI();
            this.render();
        }

        initializeUI() {
            this.phaseIndicator = document.getElementById('phaseIndicator');
            this.playerACharacters = document.getElementById('playerA-characters');
            this.playerBCharacters = document.getElementById('playerB-characters');
            this.playerABanned = document.getElementById('playerA-banned');
            this.playerBBanned = document.getElementById('playerB-banned');
            this.characterSelection = document.getElementById('characterSelection');
            this.gameBoard = document.getElementById('gameBoard');
            this.battleLog = document.getElementById('battleLog');
            this.banBtn = document.getElementById('banBtn');
            this.pickBtn = document.getElementById('pickBtn');
            this.placeBtn = document.getElementById('placeBtn');
            this.battleBtn = document.getElementById('battleBtn');
            this.resetBtn = document.getElementById('resetBtn');

            this.setupEventListeners();
            this.renderCharacters();
            this.renderBoard();
        }

        setupEventListeners() {
            this.characterSelection.addEventListener('click', (e) => {
                const card = e.target.closest('.character-card');
                if (card) {
                    const id = parseInt(card.dataset.id);
                    const character = this.game.characters.find(c => c.id === id);
                    if (character) {
                        this.game.selectedCharacter = character;
                        this.renderCharacters();
                    }
                }
            });

            this.gameBoard.addEventListener('click', (e) => {
                const cell = e.target.closest('.board-cell');
                if (cell && this.game.currentPhase === 'placement' && this.game.selectedCharacter) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    try {
                        const player = this.game.currentTurn === 'both' ? (this.game.playerA.selectedCharacters.some(c => c.id === this.game.selectedCharacter.id) ? 'playerA' : 'playerB') : this.game.currentTurn;
                        const index = this.game[player].selectedCharacters.findIndex(c => c.id === this.game.selectedCharacter.id);
                        const result = this.game.placeCharacter(player, index, row, col);
                        this.battleLog.innerHTML += `<p>${result}</p>`;
                        this.game.selectedCharacter = null;
                        this.render();
                    } catch (error) {
                        this.battleLog.innerHTML += `<p style="color: red;">${error.message}</p>`;
                    }
                }
            });

            this.banBtn.addEventListener('click', () => {
                if (this.game.selectedCharacter) {
                    try {
                        const player = this.game.currentTurn;
                        const result = this.game.banCharacter(player, this.game.selectedCharacter.id);
                        this.battleLog.innerHTML += `<p>${result}</p>`;
                        this.game.selectedCharacter = null;
                        this.render();
                    } catch (error) {
                        this.battleLog.innerHTML += `<p style="color: red;">${error.message}</p>`;
                    }
                }
            });

            this.pickBtn.addEventListener('click', () => {
                if (this.game.selectedCharacter) {
                    try {
                        const player = this.game.currentTurn;
                        const result = this.game.pickCharacter(player, this.game.selectedCharacter.id);
                        this.battleLog.innerHTML += `<p>${result}</p>`;
                        this.game.selectedCharacter = null;
                        this.render();
                    } catch (error) {
                        this.battleLog.innerHTML += `<p style="color: red;">${error.message}</p>`;
                    }
                }
            });

            this.placeBtn.addEventListener('click', () => {
                if (this.game.selectedCharacter && this.game.currentPhase === 'placement') {
                    this.battleLog.innerHTML += `<p>請點擊棋盤格子以佈置 ${this.game.selectedCharacter.name}</p>`;
                }
            });

            this.battleBtn.addEventListener('click', () => {
                if (this.game.currentPhase === 'battle') {
                    const log = this.game.executeBattleTurn();
                    log.forEach(msg => this.battleLog.innerHTML += `<p>${msg}</p>`);
                    this.render();
                }
            });

            this.resetBtn.addEventListener('click', () => {
                const result = this.game.resetGame();
                this.battleLog.innerHTML = `<p>${result}</p>`;
                this.render();
            });
        }

        renderCharacters() {
            this.characterSelection.innerHTML = '';
            const bannedIds = [
                this.game.playerA.bannedCharacter?.id,
                this.game.playerB.bannedCharacter?.id
            ];
            const selectedIds = [
                ...this.game.playerA.selectedCharacters.map(c => c.id),
                ...this.game.playerB.selectedCharacters.map(c => c.id)
            ];

            this.game.characters.forEach(character => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.dataset.id = character.id;
                if (this.game.selectedCharacter && this.game.selectedCharacter.id === character.id) {
                    card.classList.add('selected');
                }
                if (bannedIds.includes(character.id)) {
                    card.classList.add('banned');
                }
                card.innerHTML = `
                    <div>${character.name} - ${character.title}</div>
                    <div>HP: ${character.hp}, 攻擊: ${character.attack}</div>
                    <div class="status">${this.game.selectedCharacter?.id === character.id ? '已選中' : bannedIds.includes(character.id) ? '已禁用' : ''}</div>
                `;
                this.characterSelection.appendChild(card);
            });
        }

        renderBoard() {
            this.gameBoard.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    if (this.game.currentPhase === 'placement' && this.game.selectedCharacter) {
                        cell.classList.add('highlight');
                    }
                    const character = this.game.gameBoard[r][c];
                    if (character) {
                        cell.classList.add(character.owner === 'playerA' ? 'player-a' : 'player-b');
                        cell.innerHTML = `
                            <div class="character-on-board">
                                <div class="name">${character.name}</div>
                                <div class="hp">${character.hp}/${character.maxHp}</div>
                            </div>
                        `;
                    }
                    this.gameBoard.appendChild(cell);
                }
            }
        }

        renderPlayerInfo() {
            this.playerABanned.textContent = `禁用角色: ${this.game.playerA.bannedCharacter?.name || '尚未選擇'}`;
            this.playerBBanned.textContent = `禁用角色: ${this.game.playerB.bannedCharacter?.name || '尚未選擇'}`;
            this.playerACharacters.innerHTML = this.game.playerA.selectedCharacters.map(c => `
                <div class="mini-character">${c.name} (HP: ${c.hp}/${c.maxHp})</div>
            `).join('');
            this.playerBCharacters.innerHTML = this.game.playerB.selectedCharacters.map(c => `
                <div class="mini-character">${c.name} (HP: ${c.hp}/${c.maxHp})</div>
            `).join('');
        }

        render() {
            const state = this.game.getGameState();
            this.phaseIndicator.textContent = `遊戲階段: ${state.phase === 'ban' ? '禁用階段' : 
                state.phase === 'pick' ? '選擇階段' : 
                state.phase === 'placement' ? '佈置階段' : 
                state.phase === 'battle' ? '戰鬥階段' : '結束階段'} (${state.turn === 'playerA' ? '玩家A' : state.turn === 'playerB' ? '玩家B' : '雙方'})`;

            this.renderCharacters();
            this.renderBoard();
            this.renderPlayerInfo();

            const bannedIds = [this.game.playerA.bannedCharacter?.id, this.game.playerB.bannedCharacter?.id];
            const selectedIds = [...this.game.playerA.selectedCharacters.map(c => c.id), ...this.game.playerB.selectedCharacters.map(c => c.id)];
            this.banBtn.disabled = !(state.phase === 'ban' && this.game.selectedCharacter && !bannedIds.includes(this.game.selectedCharacter.id));
            this.pickBtn.disabled = !(state.phase === 'pick' && this.game.selectedCharacter && !bannedIds.includes(this.game.selectedCharacter.id) && !selectedIds.includes(this.game.selectedCharacter.id));
            this.placeBtn.disabled = !(state.phase === 'placement' && this.game.selectedCharacter);
            this.battleBtn.disabled = state.phase !== 'battle';
        }
    }

    // 啟動遊戲
    const gameFrontend = new GameFrontend();
</script>
</body>
</html>
